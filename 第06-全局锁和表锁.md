# MySQL中的锁

**根据加锁的范围，MySQL里面的锁大致分为全局锁、表级锁行锁三类。**

## 全局锁

- 对整个数据库进行实例加锁，**做全局备份**。
- FTWRL : Flush tables with read lock ; 让数据库处于只读状态，之后的其他线程的以下语句会被阻塞：数据更新语句（数据的增删改）、数据定义语句（包括建表、修改表结构等）和更新类事务的提交语句。

全局锁的缺陷，如让整个库都只读：

- 若在主库上备份，备份期间不能执行更新，业务基本上就得停摆。
- 若在从库上备份，那么备份期间从库不能执行主库同步过来的binlog，会导致主从延迟。

## 全局锁引出的思考题

- 做数据备份时为什么要全局锁？

  答：确保能够得到主从库逻辑一致的视图。

官方自带的逻辑备份工具是mysqldump。**当mysqldump使用参数-single-transaction** 的时候，导数据之前就会启动一个事务，来确保拿到一致性视图。而MVCC的支持，这个过程中数据是可以正常更新的。

- 既然有了mysqldump逻辑备份工具，为啥还需要FTWRL呢？

  答：**不是所有的引擎都支持mysqldump**。比如 MyISAM不支持事务的引擎，如果备份过程中有更新，总是能拿到最新的数据，那么破坏了备份的一致性，这时，需要使用FTWRL。所以**single-transation方法只适用于所有的表使用事务引擎的库。**

- 既然库备份时，全库只读，为什么不使用**set global readonly = true 的方式呢？**

  答：readonly 确实可以让全库进入只读状态，但建议使用FTWRL命令。有两个原因：

  1. 在某些系统中，readonly 的值会被用来做其他逻辑，比如判断一个库是主库还是备库。因此，修改global变量的方式影响很大。
  2. 在异常处理机制上有差异。如果执行FTWRL命令之后由于客户端发生异常断开了，那么MySQL会自动释放全局锁，整个库恢复正常更新的状态。而设置readonly方式的库，客户端异常断开后，数据库会一直保持readonly的状态，会导致整个库长时间处于不可写状态，风险较高。



## 表级锁

mysql中的表级锁有两种：表锁、元数据锁。

### 表锁

- 语法：lock tables ... read/write。

  与FTWRL类型，可以使用unlock tables 主动释放锁，也可以在客户端断开后自动释放。需要注意的是lock tables 语法除了会限制别的线程的读写外，也限定了本线程接下来的操作对象。

举个例子，如果在某线程A中执行 lock tables t1 read,t2 write; 这个语句，则其他线程写t1，读写t2的语句会被阻塞。在线程A未执行unlock tables 前，也只能执行读t1，读写t2的操作。

在还没有出现更细粒的锁时，表锁是最常用的处理并发的方式。而对于InnoDB这种支持行锁的引擎，一般不使用lock tables 命令来控制并发，毕竟锁住整个表的影响面还是很大的。



### 元数据锁 MDL

MDL不需要显示使用。在访问一个表的时候会被自动加上。

MDL的作用是，保证读写的正确性。

若一个查询正在遍历一个表种的数据，而执行期间有另一线程修改了表的结构，那么查询线程的结构跟表结构对不上了。

因此，在MySql5.5版本种引入MDL,当对一个表做增删改查操作的时候，加MDL读锁；当要对表结构变更操作的时候，加MDL写锁。

- 读锁之间不互斥，多个线程可同时对一张表数据进行增删改查
- 读写锁、写写锁之间互斥，用来保证变更表结构操作的安全性。因此，如果有两个线程要同时给一个表加字段，其中一个要等另一个执行完才能开始执行。

### 元数据锁常见的问题

1. 为什么给一个表加了一个字段，会导致整个数据库挂掉？

   给表加字段、加索引、或修改字段，是需要扫描全表数据的。不管大表、还是小表，我们在操作的时候都需要小心。

   备注：这里的实验环境是MySQL5.6

![img](MySQL笔记图片.assets/元数据锁引起的问题.png)

可以看到Session A先启动，这时对表t加MDL读锁，由于Session B需要的是MDL读锁，因此可以正常执行。

之后，Session C需要MDL写锁，但因Session A的MDL读锁未释而被阻塞。

接着，Session D需要申请一个MDL读锁，由于C在阻塞中，因此D也被锁不住了，之后所有需要申请MDL读的请求都会被C阻塞，那么这个表完全不可读写了。

如果某个表的查询语句频繁，而且客户端有重试机制，超时后重发新请求，那么这个库的线程会被爆满。**事务中的MDL锁，在语句开始时申请，但释放是在事务提交之后。**



2. 如何正确给表加字段、索引而不会使数据库挂掉？

   - 解决长事务，在information_schema库的innodb_trx表中，可以查看当前执行中的长事务，若有DDL变更的表刚好有长事务在执行，要先考虑暂停DDL，或者Kill掉长事务。

   - 若表为热点表，急切需要加字段或索引，这时kill掉长事务未必管用，因为上层新的请求马上就来了。可以这么做：在alter table 语句里面设定等待时间，如果在这个指定的等待时间里面能够拿到MDL写锁就好，拿不到也不要阻塞后面的业务语句，先放弃。

     MariaDB已经合并了AliSQL的这个功能，所以这两个开源分支目前都支持DDL NOWAIT/WAIT n 这个语法。

     ```sql
     ALTER TABLE tb1_name NOWAIT add cloumn...
     ALTER TABLE tb1_name WAIT N add cloumn...
     ```


## 思考题

问：做全库备份时，一般都会在备库上执行，你在用–single-transaction 方法做逻辑备份的过程中，如果主库上的一个小表做了一个 DDL，比如给一个表上加了一列。这时候，从备库上会看到什么现象呢？

master - slave  主-从库

答：主库上的表做了DDL操作，同步给slave时，因备份使用 -single-transaction方法做逻辑备份时，可能没影响，可能会主从延迟，可能会报表错误的提示（表结构发生了改变）。



分析如下：

假设这个 DDL 是针对表 t1 的， 这里我把备份过程中几个关键的语句列出来：

```sql

Q1:SET SESSION TRANSACTION ISOLATION LEVEL REPEATABLE READ;
Q2:START TRANSACTION  WITH CONSISTENT SNAPSHOT；
/* other tables */
Q3:SAVEPOINT sp;
/* 时刻 1 */
Q4:show create table `t1`;
/* 时刻 2 */
Q5:SELECT * FROM `t1`;
/* 时刻 3 */
Q6:ROLLBACK TO SAVEPOINT sp;
/* 时刻 4 */
/* other tables */
```

在备份开始的时候，为了确保 RR（可重复读）隔离级别，再设置一次 RR 隔离级别 (Q1);

启动事务，这里用 WITH CONSISTENT SNAPSHOT 确保这个语句执行完就可以得到一个一致性视图（Q2)；

设置一个保存点，这个很重要（Q3）；

show create 是为了拿到表结构 (Q4)，然后正式导数据 （Q5），回滚到 SAVEPOINT sp，在这里的作用是释放 t1 的 MDL 锁 （Q6）。当然这部分属于“超纲”，上文正文里面都没提到。

DDL 从主库传过来的时间按照效果不同，我打了四个时刻。题目设定为小表，我们假定到达后，如果开始执行，则很快能够执行完成。

参考答案如下：

1. 如果在 Q4  语句执行之前到达，现象：没有影响，备份拿到的是 DDL 后的表结构。
2. 如果在“时刻 2”到达，则表结构被改过，Q5 执行的时候，报 Table  definition has changed, please retry transaction，现象：mysqldump 终止；
3. 如果在“时刻  2”和“时刻 3”之间到达，mysqldump 占着 t1 的 MDL 读锁，binlog 被阻塞，现象：主从延迟，直到 Q6  执行完成。
4. 从“时刻 4”开始，mysqldump 释放了 MDL 读锁，现象：没有影响，备份拿到的是 DDL 前的表结构。