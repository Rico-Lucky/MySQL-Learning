# MySQL内部架构：一条更新语句是如何执行的

[极客时间-MySQL实战45讲-林小斌](https://time.geekbang.org/column/article/68633)

上一节中，提到一条查询语句从 `连接器`、`查询缓存`、`分析器`、`优化器`、`执行器`，最后到`存储引擎`这样的执行过程。

那一条更新语句是如何执行的?

先从一张表一条更新语句说起：创建一张表，表有一个主键ID和与一个整型字段c。

```sql
create table T(ID int primary key, c int)
```

如果将ID = 2这一行的值加1，SQL语句：

```sql
update T set c=c+1 where ID=2;
```

![img](MySQL笔记图片.assets/0d2070e8f84c4801adbfa03bda1f98d9.png)

上图是MySQL的架构图，更新语句也需要走一遍流程。

连接器负责数据库的连接，当更新请求语句到查询缓存时，缓存会被清空，这也是不建议使用查询缓存的原因。接下来，分析器对语句进行词法分析和语法分析，分析出这是一条要进行更新表数据操作语句。优化器选择使用ID索引，然后执行器负责具体执行，找到这一行，然后更新。

与查询流程不一样的是，更新流程涉及到两个重要的日志模块。

- **redo log (重做日志)**
- **binlog(归档日志)**

## 重要的日志模块：redo log

孔乙己酒肆掌柜场景：酒肆掌柜有一粉板，一账本，粉板用来临时记录客人的赊账记录，账本是永久记录客人的赊账情况。当有人要赊账或还账时，掌柜一般有两种做法：

- 一种是直接翻账本进行记录，扣除赊账或者加上赊账。
- 另一种是先记录在粉板中，等打烊后再把账本翻出来核算。

当生意火爆时，老板一定会选择后者，因为前者需要翻账本，密密麻麻的条目，查找慢，影响效率，就算找到了，也得核算，再写入账本中。

同理，MySQL也存在这样的问题。如果每一次的更新操作都需要写进磁盘，然后磁盘也要找对应的记录，然后再更新，整个过程的IO成本，查找成本非常高，而WAL技术解决了这问题。

### **WAL技术**：Write-Ahead Logging

其关键点是**先写日志，再写磁盘**。即先写粉板，空闲时，再写账本。

具体来说，MySQL收到一条更新语句请求，InnoDB引擎会先把记录写到 redo log中，并更新内存，这个时候算是完成了。同时，InnoDB引擎会在适当的时候，将这个操作记录更新到磁盘里，而这个更新往往是在系统比较空闲的时候做的。

若酒肆太多客人赊账了，掌柜的粉板已经写满了，这个时候，掌柜只能先把一部分粉板上的记录写进账本里了，然后把粉板上的那一部分记录擦除。这样，粉板就有空间了。

InnoDB的`redo log `也是如此。redo log的固定大小是4GB,共4个文件，每文件大小为1GB。

![img](MySQL笔记图片.assets/16a7950217b3f0f4ed02db5db59562a7.png)

如图所示：redo log从头开始写，写到末尾就又回开头循环写。

- `write pos` 是当前记录的位置，一边写一边后移,写到第3号文件末尾，就回到0号文件开头。

- `check point` 是当前要擦除的位置，也是往后推移且循环，**擦除记录前要把记录更新到数据文件**。

write pos 和 check point 之间的就是”粉板“，用来记录新的操作。当write pos 追上 check point时，表示”粉板“写满了，这时，不能再执行新的更新了，需要停下来，擦掉一些记录，把check point 往前推进。

**InnoDB特有的redo log 保证了MySQL数据库的`持久性`，即就算数据库发生异常重启，之前提交的记录都不会丢失，这能力称为 crash-safe**.



## 重要的日志模块：binlog

MySQL整体上分 Server层和引擎层。

- Sever层做功能层面的事情
- 引擎层负责数据存储相关的具体事宜

redo log 是InnoDB引擎特有的日志，而Server层也有自己的日志：binlog (归档日志)。

### 为什么需要两份日志？

因为最开始时，MySQL是没有InnoDB引擎的。其自带的引擎是MyISAM，而MyISAM没有crash-safe的功能，binlog做的是归档。因此,InnoDB被作为插件形式引入MySQL，目的是让MySQL具备crash-safe的能力,即redo log 日志。

### binlog 和 redo log的区别

1. **redo log 是InnoDB引擎特有的；binlog是MySQL的Server层实现的，所有引擎都能用**。

2. **redo log 是物理日志,记录的是”在某个数据页上做了什么修改“；binlog是逻辑日志，记录的是这个语句的原始逻辑，比如”给ID=2这一行的c字段加1“。**

3. **redo log 是循环写的，空间固定会用完；binlog是可以追加写入的。”追加写“是指binlog文件写到一定大小后会切换到下一个，并不会覆盖以前的日志。**

   



有了对这两个日志的概念理解，我们来看执行器和InnoDB引擎在执行这个简单update语句是的内部流程。

1. 执行器先找到引擎取 ID = 2这一行。ID是主键，引擎直接用树搜索找到这一行。如果ID= 2这一行所在的数据页本来就在内存中，就直接返回给执行器；否则，需要从磁盘读入内存，然后返回。

2. 执行器拿到引擎给的行数据，把这个值加上1，得到新行数据，再调用引擎接口写入这条行数据。

3. 引擎将这行数据更新到内存中，同时将这个更新操作记录写入redo log中，此时 redo log 处于prepare 状态。然后告知执行器执行完成了，随时可以提交事务。

4. 执行器生成这个操作的binlog，并把binlog写入磁盘。

5. 执行器调用引擎的提交事务接口，引擎把刚刚写的redo log 改成提交状态（commit），更新完成。

   

   以下是这个update语句的执行流程图，图中浅色框代表是在InnoDB引擎执行的，深色框代表在执行器执行的。

   ![img](MySQL笔记图片.assets/2e5bff4910ec189fe1ee6e2ecc7b4bbe.png)

由上图可知道，redo log 分两阶段提交。prepare 和 commit。



### 日志为什么需要两阶段提交？

两阶段提交目的是为了保证redo log 与 binlog 之间的逻辑一致。

怎么才能让数据库恢复到半个月内任意一秒的状态？

binlog记录的是所有的逻辑操作，并采用追加形式。如果DBA承诺说半个内可以恢复，那么备份系统中一定会保存最近半个月的所有binlog ，同时系统也会定期做整库备份。这里的定期，取决于系统的重要性，一天一备或者一周一备。

当需要恢复到指定的某一秒时，比如某天下午两点发现中午十二点有一次误删表，需要找回数据，你可以这么做：

- 首先，找到最近的一次全量备份，从这个备份恢复到临时库；

- 然后，从备份的时间点开始，将备份的binlog依次取出来，重放到中午误删表之前的那个时刻。

  

  反证法说明日志为什么需要两阶段提交。

  用前面update语句做例子，假如当前ID=2的行，字段c的值是0,再假设update过程中在写完第一个日志后，第二个日志还没有写完，期间发生了crash,会发生什么情况？

  1. 先写redo log 后写 bin log。假设在redo log 写完，bin log还没写完的时候，mysql进程异常重启。由于我们前面说的，redo log写完之后，系统就算崩溃了，也能把数据恢复回来。所以恢复后，这一行 c的值是1.

     但是由于binlog没写完就crash了，这时候binlog里面就没有这个记录的语句，因此，之后备份日志的时候，存起来的binlog里面就没有这条语句。

     然后你会发现，如果要用这个binlog来恢复临时库的话，由于这语句的binlog缺失了，这个临时库就少了一次更新，恢复出来的这一行c的值就是0，与原库的值不同。

     2. 先写bin log, 再写redo log。如果在bin log 写完后crash，由于redo log 没写，崩溃恢复以后这个事务无效，所以这一行c的值是0。但是binlog里面记录了”把c从0改为1“这个日志。所以，在之后用binlog来恢复的时候，就多了一个事务出来，恢复出来的这一行c的值就是1，与原库的值不同。

     如果不使用两阶段提交来保证两日志的逻辑一致性，那么数据库的状态就有可能和用它的日志恢复出来的库不一致。

  不止是误删操作后需要用这过程来恢复数据，当你需要扩容时，页就是需要搭建一些备库来增加系统的读写能力时，现在常见的作法时用全量备份加上应用binlog来实现的，这个”不一致“就会导致你的线上出现主从数据库不一致的情况。

  redo log 和 binlog都可以用来表示事务的提交状态，而两阶段提交就是让这两个状态保持逻辑上的一致。

  